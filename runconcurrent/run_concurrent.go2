package runconcurrent

import (
	"context"
	"sync"

	"github.com/pvillela/go-trygo2/util"
	"golang.org/x/sync/errgroup"
)

//***********************************
// The RunConcurrentXXX functions could be easily implemented using the AsyncXXX functions
// in the async package, though the implementations below may be a bit more efficient.
//***********************************

type ResultWithError[T any] struct {
	Result T
	Error  error
}

func safeGoWg[T any](
	ctx context.Context,
	wg *sync.WaitGroup,
	f func(context.Context) (T, error),
	pResult *ResultWithError[T],
) {
	wg.Add(1)
	fs := util.SafeFunc1E(f)
	go func() {
		defer wg.Done()
		res, err := fs(ctx)
		*pResult = ResultWithError[T]{res, err}
	}()
}

func RunConcurrentsWg[T any](
	ctx context.Context,
	funcs ...func(context.Context) (T, error),
) []ResultWithError[T] {
	results := make([]ResultWithError[T], len(funcs))
	wg := new(sync.WaitGroup)
	for index, f := range funcs {
		safeGoWg(ctx, wg, f, &results[index])
	}
	wg.Wait()
	return results
}

func RunConcurrent2Wg[T1, T2 any](
	ctx context.Context,
	f1 func(context.Context) (T1, error),
	f2 func(context.Context) (T2, error),
) util.Tuple2[ResultWithError[T1], ResultWithError[T2]] {
	results := util.Tuple2[ResultWithError[T1], ResultWithError[T2]]{}
	wg := new(sync.WaitGroup)
	safeGoWg(ctx, wg, f1, &results.X1)
	safeGoWg(ctx, wg, f2, &results.X2)
	wg.Wait()
	return results
}

func safeGoEg[T any](
	ctx context.Context,
	eg *errgroup.Group,
	f func(context.Context) (T, error),
	pResult *T,
) {
	fs := util.SafeFunc1E(f)
	eg.Go(func() error {
		res, err := fs(ctx)
		*pResult = res
		return err
	})
}

func RunConcurrentsEg[T any](ctx context.Context, funcs ...func(context.Context) (T, error)) ([]T, error) {
	results := make([]T, len(funcs))
	eg, ctx := errgroup.WithContext(ctx)
	for index, f := range funcs {
		safeGoEg(ctx, eg, f, &results[index])
	}
	if err := eg.Wait(); err != nil {
		return results, err
	}
	return results, nil
}

func RunConcurrent2Eg[T1, T2 any](
	ctx context.Context,
	f1 func(context.Context) (T1, error),
	f2 func(context.Context) (T2, error),
) (util.Tuple2[T1, T2], error) {
	res := util.Tuple2[T1, T2]{}
	eg, ctx := errgroup.WithContext(ctx)
	safeGoEg(ctx, eg, f1, &res.X1)
	safeGoEg(ctx, eg, f2, &res.X2)
	err := eg.Wait()
	return res, err
}
