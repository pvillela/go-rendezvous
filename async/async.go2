package async

import (
	"context"

	"github.com/pvillela/go-trygo2/util"
	"golang.org/x/sync/errgroup"
)

// This is modeled on my Kotlin Promixe
type Deferred[T any] struct {
	Value T
	Eg    *errgroup.Group
}

func (d Deferred[T]) Await() (T, error) {
	err := d.Eg.Wait()
	return d.Value, err
}

func makeDeferred[T any](
	ctx context.Context,
	eg *errgroup.Group,
	f func(ctx context.Context,
	) (T, error)) Deferred[T] {

	var deferred Deferred[T]
	deferred.Eg = eg
	eg.Go(func() (err error) {
		defer func() {
			err0 := recover()
			if err0 != nil {
				err = util.ErrorOfIfNeeded(err0)
			}
		}()
		res, err := f(ctx)
		deferred.Value = res
		return
	})
	return deferred
}

func Asyncs[T any](ctx context.Context, funcs ...func(ctx context.Context) (T, error)) []Deferred[T] {
	eg, ctx := errgroup.WithContext(ctx)
	deferred := make([]Deferred[T], len(funcs))
	for i, f := range funcs {
		i, f := i, f // avoid improper capture in closure
		eg.Go(func() error {
			// TODO: need to handle panics
			res, err := f(ctx)
			deferred[i].Value = res
			deferred[i].Eg = eg
			return err
		})
	}
	return deferred
}

func Async[T any](ctx context.Context, f func(ctx context.Context) (T, error)) Deferred[T] {
	eg, ctx := errgroup.WithContext(ctx)
	return makeDeferred(ctx, eg, f)
}

func Async2[T1 any, T2 any](
	ctx context.Context,
	f1 func(ctx context.Context) (T1, error),
	f2 func(ctx context.Context) (T2, error),
) util.Tuple2[Deferred[T1], Deferred[T2]] {

	eg, ctx := errgroup.WithContext(ctx)
	d1 := makeDeferred(ctx, eg, f1)
	d2 := makeDeferred(ctx, eg, f2)
	return util.Tuple2[Deferred[T1], Deferred[T2]]{d1, d2}
}
