package async

import (
	"context"
	"sync"

	"github.com/pvillela/go-trygo2/util"
	"golang.org/x/sync/errgroup"
)

type Deferred[T any] interface {
	Await() (T, error)
}

// This is modeled on my Kotlin Promise
type deferredEg[T any] struct {
	Value T
	Eg    *errgroup.Group
}

func (d *deferredEg[T]) Await() (T, error) {
	err := d.Eg.Wait()
	return d.Value, err
}

// This is modeled on my Kotlin Promise
type deferredWg[T any] struct {
	Value T
	Error error
	Wg    *sync.WaitGroup
}

func (d *deferredWg[T]) Await() (T, error) {
	d.Wg.Wait()
	return d.Value, d.Error
}

func AsyncOnEg[T any](
	ctx context.Context,
	eg *errgroup.Group,
	f func(ctx context.Context) (T, error),
) Deferred[T] {
	deferred := &deferredEg[T]{}
	deferred.Eg = eg
	fs := util.SafeFunc1E(f)
	eg.Go(func() error {
		res, err := fs(ctx)
		deferred.Value = res
		return err
	})
	return deferred
}

func AsyncOnWg[T any](
	ctx context.Context,
	wg *sync.WaitGroup,
	f func(ctx context.Context) (T, error),
) Deferred[T] {
	deferred := &deferredWg[T]{}
	deferred.Wg = wg
	wg.Add(1)
	fs := util.SafeFunc1E(f)
	go func() {
		defer wg.Done()
		res, err := fs(ctx)
		deferred.Value = res
		deferred.Error = err
	}()
	return deferred
}

func Async[T any](ctx context.Context, f func(ctx context.Context) (T, error)) Deferred[T] {
	var wg sync.WaitGroup
	return AsyncOnWg(ctx, &wg, f)
}

func Async2Eg[T1 any, T2 any](
	ctx context.Context,
	f1 func(ctx context.Context) (T1, error),
	f2 func(ctx context.Context) (T2, error),
) util.Tuple2[Deferred[T1], Deferred[T2]] {
	eg, ctx := errgroup.WithContext(ctx)
	d1 := AsyncOnEg(ctx, eg, f1)
	d2 := AsyncOnEg(ctx, eg, f2)
	return util.Tuple2[Deferred[T1], Deferred[T2]]{X1: d1, X2: d2}
}

func AsyncsEg[T any](ctx context.Context, funcs ...func(ctx context.Context) (T, error)) []Deferred[T] {
	eg, ctx := errgroup.WithContext(ctx)
	deferreds := make([]Deferred[T], len(funcs))
	for i, f := range funcs {
		deferreds[i] = AsyncOnEg(ctx, eg, f)
	}
	return deferreds
}

func Async2Wg[T1 any, T2 any](
	ctx context.Context,
	f1 func(ctx context.Context) (T1, error),
	f2 func(ctx context.Context) (T2, error),
) util.Tuple2[Deferred[T1], Deferred[T2]] {
	var wg sync.WaitGroup
	d1 := AsyncOnWg(ctx, &wg, f1)
	d2 := AsyncOnWg(ctx, &wg, f2)
	return util.Tuple2[Deferred[T1], Deferred[T2]]{X1: d1, X2: d2}
}

func AsyncsWg[T any](ctx context.Context, funcs ...func(ctx context.Context) (T, error)) []Deferred[T] {
	var wg sync.WaitGroup
	deferreds := make([]Deferred[T], len(funcs))
	for i, f := range funcs {
		deferreds[i] = AsyncOnWg(ctx, &wg, f)
	}
	return deferreds
}
