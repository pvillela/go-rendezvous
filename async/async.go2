package async

import (
	"context"
	"sync"

	"github.com/pvillela/go-trygo2/util"
	"golang.org/x/sync/errgroup"
)

/**********************************************************************
******* FIX DOC COMMENTS
 */

/////////////////////
// Unit

type Unit = struct{}

/////////////////////
// ResultWithError

type ResultWithError[T any] struct {
	Value T
	Error error
}

/////////////////////
// Waiter

type Waiter interface {
	Wait() error
}

// preWaiter encapsulates a context.Context and a chan error.  It supports waiting on the
// completion of an asynchronous operation while paying attention to the context's deadline.
// See its Wait() method.
type preWaiter struct {
	ctx       context.Context
	errCh     chan error
	activeCh  chan bool
	errWaitCh chan bool
	err       error
}

// Wait waits on both the ch error channel field in the receiver and the Done() channel in the
// ctx context field in the receiver.  If ctx.Done() happens first then this method returns
// a DeadlineExceeded or a Canceled error.  Otherwise, it returns the error received in ch.

// TODO: need to cache result so that multiple calls to preWait all return the same value.

func (w preWaiter) errWait() error {
	if wait := <-w.errWaitCh; wait {
		defer close(w.errWaitCh)
		err := w.err
		select {
		case errW := <-w.errCh:
			err = errW
		case <-w.ctx.Done():
			err = w.ctx.Err()
		}
		w.err = err
	}
	return w.err
}

func (w preWaiter) close() {
	if active := <-w.activeCh; active {
		close(w.activeCh)
	}
}

type ChWaiter struct {
	preWaiter
}

func MakeChWaiter(ctx context.Context) ChWaiter {
	errCh := make(chan error)
	activeCh := make(chan bool, 1)
	activeCh <- true
	errWaitCh := make(chan bool, 1)
	errWaitCh <- true
	return ChWaiter{preWaiter{ctx, errCh, activeCh, errWaitCh, nil}}
}

func (w ChWaiter) Wait() error {
	defer close(w.errCh)
	w.close()
	return w.errWait()
}

type WgWaiter struct {
	preWaiter
	wg *sync.WaitGroup
}

func MakeWgWaiter(ctx context.Context) WgWaiter {
	wg := new(sync.WaitGroup)
	errCh := make(chan error)
	activeCh := make(chan bool, 1)
	activeCh <- true
	errWaitCh := make(chan bool, 1)
	errWaitCh <- true
	return WgWaiter{preWaiter{ctx, errCh, activeCh, errWaitCh, nil}, wg}
}

func (w WgWaiter) Wait() error {
	defer close(w.errCh)
	w.close()
	go func() {
		defer close(w.errCh)
		w.wg.Wait()
	}()
	return w.errWait()
}

type EgWaiter struct {
	preWaiter
	eg     *errgroup.Group
	cancel func()
}

// MakeEgWaiter creates an errgroup.Group encapsulated in a Waiter for use with error groups.
func MakeEgWaiter(ctx context.Context) EgWaiter {
	eg, _ := errgroup.WithContext(ctx)
	ctx, cancel := context.WithCancel(ctx)
	errCh := make(chan error)
	activeCh := make(chan bool, 1)
	activeCh <- true
	errWaitCh := make(chan bool, 1)
	errWaitCh <- true
	return EgWaiter{preWaiter{ctx, errCh, activeCh, errWaitCh, nil}, eg, cancel}
}

func (w EgWaiter) Wait() error {
	defer close(w.errCh)
	w.close()
	go func() {
		defer close(w.errCh)
		err := w.eg.Wait()
		w.errCh <- err
		if err != nil {
			w.cancel()
		}
	}()
	return w.errWait()
}

/////////////////////
// SafeGo

// SafeGoCh launches f as a saparate goroutine and puts its result in the struct pointed to by
// pResult.
// Before using the result, a caller must wait on the Waiter passed into this function.
// If f panics, the panic value is converted to an error and set in the result.
func SafeGoCh[T any](
	w ChWaiter,
	f func(context.Context) (T, error),
	pResult *ResultWithError[T],
) {
	if active := <-w.activeCh; active {
		defer func() { w.activeCh <- true }() // keep it active
		fs := util.SafeFunc1E(f)
		go func() {
			defer close(w.errCh)
			res, err := fs(w.ctx)
			*pResult = ResultWithError[T]{res, err}
		}()
	}
}

// SafeGoWg launches f as a saparate goroutine and puts its result in the struct pointed to by
// pResult.
// Before using the result, a caller must wait on the Waiter returned by this function..
// If f panics, the panic value is converted to an error and set in the result.
func SafeGoWg[T any](
	w WgWaiter,
	f func(context.Context) (T, error),
	pResult *ResultWithError[T],
) {
	w.wg.Add(1)
	fs := util.SafeFunc1E(f)
	go func() {
		defer w.wg.Done()
		res, err := fs(w.ctx)
		*pResult = ResultWithError[T]{res, err}
	}()
}

// SafeGoEg launches f as a saparate goroutine and puts its non-error result in the struct
// pointed to by pResult.
// Before using the result, a caller must wait on the Waiter returned by this function..
// If f panics, the panic value is converted to an error and set in the result.
//
// ctx is the parent context used in the call to errgroup.WithContext.
//
// This function creates a child context of ctx (with a cancellation function) that is passed
// to f.  The cancellation function is used specifically
// to signal functions in the error group that one of the functions in the group returned an
// error.  This is required because the context created by the errgroup.WithContext function
// is not passed to the functions.  The reason for that is that the error group context
// ignores the parent context's deadline and cancellation.  This way, the functions in the
// error group will be notified if either the parent context times out or the parent context
// is cancelled or the error group context is cancelled (due to an error in a peer function).
func SafeGoEg[T any](
	w EgWaiter,
	f func(context.Context) (T, error),
	pResult *T,
) {
	fs := util.SafeFunc1E(f)
	w.eg.Go(func() error {
		res, err := fs(w.ctx)
		*pResult = res
		return err
	})
}

/////////////////////
// RunConcurrent

// RunConcurrentsWg runs funcs concurrently and returns a slice containing the results of
// the function executions once all functions complete normaly, with an error, or with a panic.
// Panics in function executions are converted to errors.
// In case of a context timeout or cancellation, this functionn returns early with a
// TimeoutError or CancellationError.
func RunConcurrentsWg[T any](
	ctx context.Context,
	funcs ...func(context.Context) (T, error),
) ([]ResultWithError[T], error) {
	results := make([]ResultWithError[T], len(funcs))
	waiter := MakeWgWaiter(ctx)
	for index, f := range funcs {
		SafeGoWg(waiter, f, &results[index])
	}
	err := waiter.errWait()
	return results, err
}

// RunConcurrent2Wg runs funcs concurrently and returns a slice containing the results of
// the function executions once all functions complete normaly, with an error, or with a panic.
// Panics in function executions are converted to errors.
// In case of a context timeout or cancellation, this functionn returns early with a
// TimeoutError or CancellationError.
func RunConcurrent2Wg[T1, T2 any](
	ctx context.Context,
	f1 func(context.Context) (T1, error),
	f2 func(context.Context) (T2, error),
) (util.Tuple2[ResultWithError[T1], ResultWithError[T2]], error) {
	results := util.Tuple2[ResultWithError[T1], ResultWithError[T2]]{}
	waiter := MakeWgWaiter(ctx)
	SafeGoWg(waiter, f1, &results.X1)
	SafeGoWg(waiter, f2, &results.X2)
	err := waiter.errWait()
	return results, err
}

// RunConcurrentsEg runs funcs concurrently and returns a slice containing the non-error results
// of the function executions if all functions complete normaly.  If any of the functions
// returns an error or panics, this function returns early, with the first error encountered.
// Panics in function executions are converted to errors.
// In case of a context timeout or cancellation, this functionn returns early with a
// TimeoutError or CancellationError.
func RunConcurrentsEg[T any](
	ctx context.Context,
	funcs ...func(context.Context) (T, error),
) ([]T, error) {
	results := make([]T, len(funcs))
	waiter := MakeEgWaiter(ctx)
	for index, f := range funcs {
		SafeGoEg(waiter, f, &results[index])
	}
	err := waiter.errWait()
	return results, err
}

// RunConcurrent2Eg runs funcs concurrently and returns a slice containing the non-error results
// of the function executions if all functions complete normaly.  If any of the functions
// returns an error or panics, this function returns early, with the first error encountered.
// Panics in function executions are converted to errors.
// In case of a context timeout or cancellation, this functionn returns early with a
// TimeoutError or CancellationError.
func RunConcurrent2Eg[T1, T2 any](
	ctx context.Context,
	f1 func(context.Context) (T1, error),
	f2 func(context.Context) (T2, error),
) (util.Tuple2[T1, T2], error) {
	res := util.Tuple2[T1, T2]{}
	waiter := MakeEgWaiter(ctx)
	SafeGoEg(waiter, f1, &res.X1)
	SafeGoEg(waiter, f2, &res.X2)
	err := waiter.errWait()
	return res, err
}

/////////////////////
// Promise

type Promise[T any] interface {
	Await() (T, error)
}

type PromiseImpl[T any] struct {
	ResWE  ResultWithError[T] // can't use embedded struct with go2go
	Waiter Waiter
}

func (p *PromiseImpl[T]) Await() (T, error) {
	errW := p.Waiter.Wait()
	value := p.ResWE.Value
	err := p.ResWE.Error
	if errW != nil {
		err = errW
	}
	return value, err
}

func Async[T any](
	ctx context.Context,
	f func(context.Context) (T, error),
) Promise[T] {
	promImpl := PromiseImpl[T]{}
	pResWE := &promImpl.ResWE
	waiter := MakeChWaiter(ctx)
	promImpl.Waiter = waiter
	SafeGoCh(waiter, f, pResWE)
	return &promImpl
}

func Async2Eg[T1 any, T2 any](
	ctx context.Context,
	f1 func(ctx context.Context) (T1, error),
	f2 func(ctx context.Context) (T2, error),
) Promise[util.Tuple2[T1, T2]] {
	f := func(ctx context.Context) (util.Tuple2[T1, T2], error) {
		return RunConcurrent2Eg[T1, T2](ctx, f1, f2)
	}
	return Async(ctx, f)
}

func AsyncsEg[T any](
	ctx context.Context,
	funcs ...func(ctx context.Context) (T, error),
) Promise[[]T] {
	f := func(ctx context.Context) ([]T, error) {
		return RunConcurrentsEg[T](ctx, funcs...)
	}
	return Async(ctx, f)
}

func Async2Wg[T1 any, T2 any](
	ctx context.Context,
	f1 func(ctx context.Context) (T1, error),
	f2 func(ctx context.Context) (T2, error),
) Promise[util.Tuple2[ResultWithError[T1], ResultWithError[T2]]] {
	f := func(ctx context.Context) (util.Tuple2[ResultWithError[T1], ResultWithError[T2]], error) {
		return RunConcurrent2Wg[T1, T2](ctx, f1, f2)
	}
	return Async(ctx, f)
}

func AsyncsWg[T any](
	ctx context.Context,
	funcs ...func(ctx context.Context) (T, error),
) Promise[[]ResultWithError[T]] {
	f := func(ctx context.Context) ([]ResultWithError[T], error) {
		return RunConcurrentsWg[T](ctx, funcs...)
	}
	return Async(ctx, f)
}

func RunInBackground[T any](
	ctx context.Context,
	f func(context.Context) (T, error),
	errorHandler func(error),
) (T, error) {
	f1 := func(ctx context.Context) (T, error) {
		res, err := f(ctx)
		errorHandler(err)
		return res, err
	}
	promise := Async(ctx, f1)
	return promise.Await()
}
