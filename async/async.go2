package async

import (
	"context"
	"sync"

	"github.com/pvillela/go-trygo2/util"
	"golang.org/x/sync/errgroup"
)

/////////////////////
// ResultWithError

type ResultWithError[T any] struct {
	Value T
	Error error
}

/////////////////////
// SafeGo

// safeGoMx is only used in the implementation of Async.
// It launches f as a saparate goroutine and puts its result in the struct pointed to by
// pResult.  Before using the result, a caller must acquire a lock on the returned sync.Locker.
// If f panics, the panic value is converted to an error and set in the result.
func safeGoMx[T any](
	ctx context.Context,
	f func(context.Context) (T, error),
	pResult *ResultWithError[T],
) sync.Locker {
	lock := new(sync.RWMutex)
	lock.Lock()
	fs := util.SafeFunc1E(f)
	go func() {
		defer lock.Unlock()
		res, err := fs(ctx)
		*pResult = ResultWithError[T]{res, err}
	}()
	return lock.RLocker()
}

// SafeGoWg launches f as a saparate goroutine and puts its result in the struct pointed to by
// pResult.  Before using the result, a caller must wait on the sync.WaitGroup wg.
// If f panics, the panic value is converted to an error and set in the result.
func SafeGoWg[T any](
	ctx context.Context,
	wg *sync.WaitGroup,
	f func(context.Context) (T, error),
	pResult *ResultWithError[T],
) {
	wg.Add(1)
	fs := util.SafeFunc1E(f)
	go func() {
		defer wg.Done()
		res, err := fs(ctx)
		*pResult = ResultWithError[T]{res, err}
	}()
}

// SafeGoWg launches f as a saparate goroutine and puts its result in the struct pointed to by
// pResult.  Before using the result, a caller must wait on eg.  If f panics, the panic value
// is converted to an error and is fed to the errgroup.Group eg.
func SafeGoEg[T any](
	ctx context.Context,
	eg *errgroup.Group,
	f func(context.Context) (T, error),
	pResult *T,
) {
	fs := util.SafeFunc1E(f)
	eg.Go(func() error {
		res, err := fs(ctx)
		*pResult = res
		return err
	})
}

/////////////////////
// RunConcurrent

func RunConcurrentsWg[T any](
	ctx context.Context,
	funcs ...func(context.Context) (T, error),
) []ResultWithError[T] {
	results := make([]ResultWithError[T], len(funcs))
	wg := new(sync.WaitGroup)
	for index, f := range funcs {
		SafeGoWg(ctx, wg, f, &results[index])
	}
	wg.Wait()
	return results
}

func RunConcurrent2Wg[T1, T2 any](
	ctx context.Context,
	f1 func(context.Context) (T1, error),
	f2 func(context.Context) (T2, error),
) util.Tuple2[ResultWithError[T1], ResultWithError[T2]] {
	results := util.Tuple2[ResultWithError[T1], ResultWithError[T2]]{}
	wg := new(sync.WaitGroup)
	SafeGoWg(ctx, wg, f1, &results.X1)
	SafeGoWg(ctx, wg, f2, &results.X2)
	wg.Wait()
	return results
}

func RunConcurrentsEg[T any](
	ctx context.Context,
	funcs ...func(context.Context) (T, error),
) ([]T, error) {
	results := make([]T, len(funcs))
	eg, ctx := errgroup.WithContext(ctx)
	for index, f := range funcs {
		SafeGoEg(ctx, eg, f, &results[index])
	}
	if err := eg.Wait(); err != nil {
		return results, err
	}
	return results, nil
}

func RunConcurrent2Eg[T1, T2 any](
	ctx context.Context,
	f1 func(context.Context) (T1, error),
	f2 func(context.Context) (T2, error),
) (util.Tuple2[T1, T2], error) {
	res := util.Tuple2[T1, T2]{}
	eg, ctx := errgroup.WithContext(ctx)
	SafeGoEg(ctx, eg, f1, &res.X1)
	SafeGoEg(ctx, eg, f2, &res.X2)
	err := eg.Wait()
	return res, err
}

/////////////////////
// Promise

type Promise[T any] interface {
	Await() (T, error)
}

type promiseMx[T any] struct {
	ResWE ResultWithError[T] // can't use embedded struct with go2go
	Lock  sync.Locker
}

func (p *promiseMx[T]) Await() (T, error) {
	defer p.Lock.Unlock()
	p.Lock.Lock()
	return p.ResWE.Value, p.ResWE.Error
}

type promiseEg[T any] struct {
	Value T
	Eg    *errgroup.Group
}

func (p *promiseEg[T]) Await() (T, error) {
	err := p.Eg.Wait()
	return p.Value, err
}

type promiseWg[T any] struct {
	ResWE ResultWithError[T] // can't use embedded struct with go2go
	Wg    *sync.WaitGroup
}

func (p *promiseWg[T]) Await() (T, error) {
	p.Wg.Wait()
	return p.ResWE.Value, p.ResWE.Error
}

func Async[T any](
	ctx context.Context,
	f func(context.Context) (T, error),
) Promise[T] {
	promise := new(promiseMx[T])
	pResWE := &promise.ResWE
	lock := safeGoMx(ctx, f, pResWE)
	promise.Lock = lock
	return promise
}

func AsyncOnEg[T any](
	ctx context.Context,
	eg *errgroup.Group,
	f func(ctx context.Context) (T, error),
) Promise[T] {
	promise := new(promiseEg[T])
	pRes := &promise.Value
	SafeGoEg(ctx, eg, f, pRes)
	promise.Eg = eg
	return promise
}

func AsyncOnWg[T any](
	ctx context.Context,
	wg *sync.WaitGroup,
	f func(ctx context.Context) (T, error),
) Promise[T] {
	promise := new(promiseWg[T])
	pResWE := &promise.ResWE
	SafeGoWg(ctx, wg, f, pResWE)
	promise.Wg = wg
	return promise
}

func Async2Eg[T1 any, T2 any](
	ctx context.Context,
	f1 func(ctx context.Context) (T1, error),
	f2 func(ctx context.Context) (T2, error),
) Promise[util.Tuple2[T1, T2]] {
	f := func(ctx context.Context) (util.Tuple2[T1, T2], error) {
		return RunConcurrent2Eg[T1, T2](ctx, f1, f2)
	}
	return Async(ctx, f)
}

func AsyncsEg[T any](
	ctx context.Context,
	funcs ...func(ctx context.Context) (T, error),
) Promise[[]T] {
	f := func(ctx context.Context) ([]T, error) {
		return RunConcurrentsEg[T](ctx, funcs...)
	}
	return Async(ctx, f)
}

func Async2Wg[T1 any, T2 any](
	ctx context.Context,
	f1 func(ctx context.Context) (T1, error),
	f2 func(ctx context.Context) (T2, error),
) Promise[util.Tuple2[ResultWithError[T1], ResultWithError[T2]]] {
	f := func(ctx context.Context) (util.Tuple2[ResultWithError[T1], ResultWithError[T2]], error) {
		return RunConcurrent2Wg[T1, T2](ctx, f1, f2), nil
	}
	return Async(ctx, f)
}

func AsyncsWg[T any](
	ctx context.Context,
	funcs ...func(ctx context.Context) (T, error),
) Promise[[]ResultWithError[T]] {
	f := func(ctx context.Context) ([]ResultWithError[T], error) {
		return RunConcurrentsWg[T](ctx, funcs...), nil
	}
	return Async(ctx, f)
}
