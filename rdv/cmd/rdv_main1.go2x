package main

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/pvillela/go-trygo2/util"
	"golang.org/x/sync/errgroup"
)

/////////////////////
// Unit

// Unit is a type alias
type Unit = struct{}

/////////////////////
// ResultWithError

// ResultWithError encapsulates a normal result value and an error.
type ResultWithError[T any] struct {
	Value T
	Error error
}

/////////////////////
// Rdv

// rdvData is the data structure used by Rdv channels.
type rdvData[T any] struct {
	Value    T
	Error    error
	ChanOpen bool
}

// Rdv is a channel used for a function launched as a goroutine to rendezvous with the user of
// the function's results.
type Rdv[T any] chan rdvData[T]

// Receive waits on the receiver and returns the results of the asynchronous computation for
// which the receiver was created (see Go and GoEg).
// This function may only be called once.
func (rdv Rdv[T]) Receive() (T, error) {
	data := <-rdv
	if !data.ChanOpen {
		panic("attempt to get data from closed rendezvous channel")
	}
	return data.Value, data.Error
}

// ReceiveCtx waits on the receiver and watches the context ctx for cancellation or timeout.
// If ctx is not cancelled or times-out, this function returns the results of the asynchronous
// computation for which the receiver was created (see Go and GoEg).
// Otherwise, this function returns early with a TimeoutError or CancellationError.
// This function may only be called once.
func (rdv Rdv[T]) ReceiveCtx(ctx context.Context) (T, error) {
	data := rdvData[T]{}
	select {
	case data = <-rdv:
		if !data.ChanOpen {
			panic("attempt to get data from closed rendezvous channel")
		}
	case <-ctx.Done():
		data.Error = ctx.Err()
	}
	return data.Value, data.Error
}

// Go launches f as an asynchronous computation in a goroutine and returns an Rdv instance
// to be used to retrieve the results of the computation.
func Go[T any](f func() (T, error)) Rdv[T] {
	rdv := make(Rdv[T])
	go func() {
		defer close(rdv)
		fs := util.SafeFunc0E(f)
		res, err := fs()
		data := rdvData[T]{res, err, true}
		rdv <- data
	}()
	return rdv
}

// GoEg launches f as an asynchronous computation in a goroutine associated with the
// errgroup.Group eg and returns an Rdv instance to be used to retrieve the results of
// the computation.
func GoEg[T any](eg *errgroup.Group, f func() (T, error)) Rdv[T] {
	rdv := make(Rdv[T])
	eg.Go(func() error {
		defer close(rdv)
		fs := util.SafeFunc0E(f)
		res, err := fs()
		data := rdvData[T]{res, err, true}
		rdv <- data
		return err
	})
	return rdv
}

func f1(_ context.Context) (int, error) {
	fmt.Println(">>> f1 starting")
	time.Sleep(10 * time.Millisecond)
	fmt.Println("<<< f1 finishing")
	return 1, nil
}

func f2(_ context.Context) (int, error) {
	fmt.Println(">>> f2 starting")
	time.Sleep(20 * time.Millisecond)
	fmt.Println("<<< f2 finishing")
	panic("f2 panicked")
}

func f3(_ context.Context) (int, error) {
	fmt.Println(">>> f3 starting")
	time.Sleep(30 * time.Millisecond)
	fmt.Println("<<< f3 finishing")
	return 0, errors.New("f3 errored-out")
}

func f4(ctx context.Context) (int, error) {
	fmt.Println(">>> f4 starting")
	time.Sleep(40 * time.Millisecond)
	fmt.Println("<<< f4 finishing")
	if ctx.Err() != nil {
		return 444, errors.New("f4 aborted")
	}
	return 4, nil
}

func f5(ctx context.Context) (int, error) {
	fmt.Println(">>> f5 starting")
	valDur := int64(50 * time.Millisecond)
	shorDur := time.Duration(valDur / 10)
	for i := 0; i < 10; i++ {
		if ctx.Err() != nil {
			fmt.Println("<<< f5 aborting")
			return 555, errors.New(fmt.Sprintf("f5 aborted on iteration %v", i))
		}
		time.Sleep(shorDur)
	}
	fmt.Println("<<< f5 finishing")
	return 5, nil
}

func f6(_ context.Context) (int, error) {
	fmt.Println(">>> f6 starting")
	time.Sleep(60 * time.Millisecond)
	fmt.Println("<<< f6 finishing")
	return 6, nil
}

type Ctx struct {
	c context.Context
}

var wastedCancel func()

func ctxTO(millis int64) Ctx {
	timeout := time.Duration(millis) * time.Millisecond
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	wastedCancel = cancel
	return Ctx{ctx}
}

func (ctx Ctx) inj(f func(context.Context) (int, error)) func() (int, error) {
	return func() (int, error) {
		return f(ctx.c)
	}
}

func main() {

	func() {
		fmt.Println("\n*** RdvGo 1")
		rv := Go(ctxTO(49).inj(f1))
		fmt.Println(rv.Receive())
	}()

	func() {
		fmt.Println("\n*** RdvGo 2")
		rv := Go(ctxTO(49).inj(f2))
		fmt.Println(rv.Receive())
	}()

	func() {
		fmt.Println("\n*** RdvGo 3")
		rv := Go(ctxTO(49).inj(f3))
		fmt.Println(rv.Receive())
	}()

	func() {
		fmt.Println("\n*** RdvGo 4")
		rv := Go(ctxTO(49).inj(f4))
		fmt.Println(rv.Receive())
	}()

	func() {
		fmt.Println("\n*** RdvGo 5")
		rv := Go(ctxTO(49).inj(f5))
		fmt.Println(rv.Receive())
	}()

	func() {
		fmt.Println("\n*** RdvGo 6")
		rv := Go(ctxTO(49).inj(f6))
		fmt.Println(rv.Receive())
	}()

	func() {
		fmt.Println("\n*** RdvGo 1 ReceiveCtx")
		C := ctxTO(49)
		rv := Go(C.inj(f1))
		fmt.Println(rv.ReceiveCtx(C.c))
	}()

	func() {
		fmt.Println("\n*** RdvGo 2 ReceiveCtx")
		C := ctxTO(49)
		rv := Go(C.inj(f2))
		fmt.Println(rv.ReceiveCtx(C.c))
	}()

	func() {
		fmt.Println("\n*** RdvGo 3 ReceiveCtx")
		C := ctxTO(49)
		rv := Go(C.inj(f3))
		fmt.Println(rv.ReceiveCtx(C.c))
	}()

	func() {
		fmt.Println("\n*** RdvGo 4 ReceiveCtx")
		C := ctxTO(49)
		rv := Go(C.inj(f4))
		fmt.Println(rv.ReceiveCtx(C.c))
	}()

	func() {
		fmt.Println("\n*** RdvGo 5 ReceiveCtx")
		C := ctxTO(49)
		rv := Go(C.inj(f5))
		fmt.Println(rv.ReceiveCtx(C.c))
	}()

	func() {
		fmt.Println("\n*** RdvGo 6 ReceiveCtx")
		C := ctxTO(49)
		rv := Go(C.inj(f6))
		fmt.Println(rv.ReceiveCtx(C.c))
	}()

	func() {
		fmt.Println("\n*** RdvEgGo 12")
		C := ctxTO(49)
		eg, egCtx := errgroup.WithContext(C.c)
		Ceg := Ctx{egCtx}
		rvA := GoEg(eg, Ceg.inj(f1))
		fmt.Println(rvA.Receive())
		rvB := GoEg(eg, Ceg.inj(f2))
		fmt.Println(rvB.Receive())
	}()

	func() {
		fmt.Println("\n*** RdvEgGo 12 ReceiveCtx")
		C := ctxTO(49)
		eg, egCtx := errgroup.WithContext(C.c)
		Ceg := Ctx{egCtx}
		rvA := GoEg(eg, Ceg.inj(f1))
		fmt.Println(rvA.ReceiveCtx(C.c))
		rvB := GoEg(eg, Ceg.inj(f2))
		fmt.Println(rvB.ReceiveCtx(C.c))
	}()
}
